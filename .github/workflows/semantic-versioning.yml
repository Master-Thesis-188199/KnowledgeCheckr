name: Automatic Semantic Versioning

on:
  push:
    branches:
      - main
      - canary
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  REPO_NAME: ${{ github.repository }}
  GHCR_IMAGE: ghcr.io/${{ github.repository }}

concurrency:
  # This concurrency group ensures that only one job in the group runs at a time.
  # If a new job is triggered, the previous one will be canceled.
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  semantic-versioning:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: "0"

      - name: Set up Node 24.11.1
        uses: actions/setup-node@v6
        with:
          node-version: 24.11.1

      - name: Install dependencies
        run: yarn --frozen-lockfile

      - name: Run semantice release
        run: |
          npm run semantic-release

  # The build job builds the Docker image for each platform specified in the matrix.
  build:
    needs: [semantic-versioning]
    strategy:
      fail-fast: false
      matrix:
        platform:
          - linux/amd64
          - linux/arm64

    runs-on: ${{ matrix.platform == 'linux/amd64' && 'ubuntu-latest' || matrix.platform == 'linux/arm64' && 'ubuntu-24.04-arm' }}
    # The job runs on different runners based on the platform.
    # For linux/amd64, it runs on the latest Ubuntu runner.
    # For linux/arm64, it runs on an Ubuntu 24.04 ARM runner.
    # The runner is selected based on the platform specified in the matrix.

    name: Build Docker image for ${{ matrix.platform }}

    steps:
      - name: Transform image name to be lower-case
        run: echo "GHCR_IMAGE=$(echo ${{ env.GHCR_IMAGE }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Prepare environment for current platform
        # This step sets up the environment for the current platform being built.
        # It replaces the '/' character in the platform name with '-' and sets it as an environment variable.
        # This is useful for naming artifacts and other resources that cannot contain '/'.
        # The environment variable PLATFORMS_PAIR will be used later in the workflow.
        id: prepare
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        # This step checks out the code from the repository.
        # It uses the actions/checkout action to clone the repository into the runner's workspace.

      - name: Docker meta default
        # This step generates metadata for the Docker image.
        # It uses the docker/metadata-action to create metadata based on the repository information.
        # The metadata includes information such as the image name, tags, and labels.
        # The metadata will be used later in the workflow to build and push the Docker image.
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ env.GHCR_IMAGE }}

      - name: Set up Docker Context for Buildx
        # This step sets up a Docker context for Buildx.
        # It creates a new context named "builders" that will be used for building the Docker image.
        # The context allows Buildx to use the Docker daemon for building images.
        id: buildx-context
        run: |
          docker context create builders

      - name: Set up Docker Buildx
        # This step sets up Docker Buildx, which is a Docker CLI plugin for extended build capabilities with BuildKit.
        # It uses the docker/setup-buildx-action to configure Buildx with the specified context and platforms.
        # The platforms are specified in the matrix and will be used for building the Docker image.
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1
        with:
          endpoint: builders
          platforms: ${{ matrix.platform }}

      - name: Login to GitHub Container Registry
        # This step logs in to the GitHub Container Registry (GHCR) using the docker/login-action.
        # It uses the GitHub actor's username and the GITHUB_TOKEN secret for authentication.
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: 0ndt/envfile@v2
        name: Collect repository variables
        with:
          secrets: ${{ toJSON(vars) }}
          file: ".env-vars"

      - uses: 0ndt/envfile@v2
        name: Collect repository secrets
        with:
          secrets: ${{ toJSON(secrets)   }}
          file: ".env-secrets"
          exclude: GH_TOKEN, GITHUB_TOKEN

      - name: Create .env File
        run: |
          cat .env-vars >> .env && cat .env-secrets >> .env

      - name: Build and push by digest
        # This step builds and pushes the Docker image using Buildx.
        # It uses the docker/build-push-action to build the image with the specified context and platforms.
        # The image is built with the labels and annotations generated in the previous steps.
        # The outputs are configured to push the image by digest, which allows for better caching and versioning.
        # The cache-from and cache-to options are used to enable caching for the build process.
        # The cache is stored in GitHub Actions cache and is scoped to the repository, branch, and platform.
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        env:
          DOCKER_BUILDKIT: 1
          BUILDX_NO_DEFAULT_ATTESTATIONS: 1
        with:
          context: .
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          annotations: ${{ steps.meta.outputs.annotations }}
          outputs: type=image,name=${{ env.GHCR_IMAGE }},push-by-digest=true,name-canonical=true,push=true,oci-mediatypes=true
          cache-from: type=gha,scope=${{ github.repository }}-${{ github.ref_name }}-${{ matrix.platform }}
          cache-to: type=gha,scope=${{ github.repository }}-${{ github.ref_name }}-${{ matrix.platform }}

      - name: Export digest
        # This step exports the digest of the built image to a file.
        # It creates a directory in /tmp/digests and saves the digest of the image to a file.
        # The digest is obtained from the output of the build step.
        # The digest is used to uniquely identify the built image and can be used for further processing or verification.
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        # This step uploads the digest file to the GitHub Actions artifact storage.
        # It uses the actions/upload-artifact action to upload the file created in the previous step.
        # The artifact is named digests-${{ env.PLATFORM_PAIR }}, where PLATFORM_PAIR is the platform name with '/' replaced by '-'.
        # The artifact is retained for 1 day, and if no files are found, it will throw an error.
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: digests-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge-images-into-manifest:
    # This job merges the Docker manifests for the different platforms built in the previous job.
    name: Merge Docker manifests
    runs-on: ubuntu-latest

    needs:
      - build
      # This job depends on the build job to complete before it starts.
      # It ensures that the Docker images for all platforms are built before merging the manifests.
    steps:
      - name: Transform image name to be lower-case
        run: echo "GHCR_IMAGE=$(echo ${{ env.GHCR_IMAGE }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Checkout with tags
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Previous tag
        id: previoustag
        uses: WyriHaximus/github-action-get-previous-tag@v1

      - name: Download digests
        # This step downloads the digest files uploaded in the build job.
        # It uses the actions/download-artifact action to download the artifacts with the pattern digests-*.
        # The downloaded files are merged into the /tmp/digests directory.
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          path: /tmp/digests
          pattern: digests-*
          merge-multiple: true

      - name: Docker meta
        # This step generates metadata for the Docker image.
        # It uses the docker/metadata-action to create metadata based on the repository information.
        # The metadata includes information such as the image name, tags, and labels.
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ env.GHCR_IMAGE }}
          annotations: |
            type=org.opencontainers.image.description,value=${{ github.event.repository.description || 'No description provided' }}
          tags: |
            type=raw,value=dummy-test-tag

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1
        # This step sets up Docker Buildx, which is a Docker CLI plugin for extended build capabilities with BuildKit.
        with:
          driver-opts: |
            network=host

      - name: Login to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        # This step logs in to the GitHub Container Registry (GHCR) using the docker/login-action.
        # It uses the GitHub actor's username and the GITHUB_TOKEN secret for authentication.
        # The login is necessary to push the merged manifest list to GHCR.
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get execution timestamp with RFC3339 format
        # This step gets the current execution timestamp in RFC3339 format.
        # It uses the date command to get the current UTC time and formats it as a string.
        # The timestamp is used for annotating the Docker manifest list.
        id: timestamp
        run: |
          echo "timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT

      - name: Create manifest list and pushs
        # This step creates a manifest list for the Docker images built for different platforms.
        # It uses the docker buildx imagetools create command to create the manifest list.
        # The manifest list is annotated with metadata such as description, creation timestamp, and source URL.
        # The annotations are obtained from the metadata generated in the previous steps.
        # The manifest list is pushed to the GitHub Container Registry (GHCR) with the specified tags.
        working-directory: /tmp/digests
        id: manifest-annotate
        continue-on-error: true
        run: |
          docker buildx imagetools create \
            $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            --annotation='index:org.opencontainers.image.description=${{ github.event.repository.description }}' \
            --annotation='index:org.opencontainers.image.created=${{ steps.timestamp.outputs.timestamp }}' \
            --annotation='index:org.opencontainers.image.url=${{ github.event.repository.url }}' \
            --annotation='index:org.opencontainers.image.source=${{ github.event.repository.url }}' \
            $(printf '${{ env.GHCR_IMAGE }}@sha256:%s ' *)

      - name: Create manifest list and push without annotations
        # This step creates a manifest list for the Docker images built for different platforms.
        # It uses the docker buildx imagetools create command to create the manifest list.
        # The manifest list is created without annotations if the previous step fails.
        # The manifest list is pushed to the GitHub Container Registry (GHCR) with the specified tags.
        if: steps.manifest-annotate.outcome == 'failure'
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create  $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.GHCR_IMAGE }}@sha256:%s ' *)

      - name: Inspect image
        # This step inspects the created manifest list to verify its contents.
        # It uses the docker buildx imagetools inspect command to display information about the manifest list.
        # The inspection output will show the platforms and tags associated with the manifest list.
        id: inspect
        run: |
          docker buildx imagetools inspect '${{ env.GHCR_IMAGE }}:${{ steps.meta.outputs.version }}'

  schema-modified:
    runs-on: ubuntu-latest
    name: "Check for Database Schema Update"
    outputs:
      db_changed: ${{ steps.changed.outputs.db_changed }}

    steps:
      - name: Checkout with tags
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Did init.sql change ? (all commits included in the push)
      - name: Check if database/init.sql changed in this push
        id: changed
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ github.event.before }}"
          HEAD="${{ github.sha }}"
          # Fallback for cases where 'before' may be empty (e.g. first push)
          if [ -z "$BASE" ] || ! git cat-file -e "$BASE^{commit}" 2>/dev/null; then
            BASE="$(git rev-parse "${HEAD}^" 2>/dev/null || true)"
          fi
          echo "Diff range: ${BASE:-<none>}..${HEAD}"
          if [ -n "$BASE" ] && git diff --name-only "$BASE" "$HEAD" | grep -qx 'database/init.sql'; then
            echo "db_changed=true" >> "$GITHUB_OUTPUT"
            echo "Database schema (init.sql) has changed."
          else
            echo "db_changed=false" >> "$GITHUB_OUTPUT"
            echo "Database schema (init.sql) has **not** changed. Aborting."
          fi

  build-db-image:
    runs-on: ubuntu-latest
    name: "Build new Database Docker Image"
    needs: [schema-modified, semantic-versioning]

    steps:
      - name: Checkout with tags
        if: needs.schema-modified.outputs.db_changed == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Stop if not changed
        if: needs.schema-modified.outputs.db_changed == 'false'
        run: echo "init.sql not changed since previous release â€” skipping image build."

      - name: Set up QEMU
        if: needs.schema-modified.outputs.db_changed == 'true'
        uses: docker/setup-qemu-action@v3

      - name: Log in to GHCR
        if: needs.schema-modified.outputs.db_changed == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        if: needs.schema-modified.outputs.db_changed == 'true'
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          platforms: linux/amd64,linux/arm64

      - name: Compute Dynamic Image Tag
        if: needs.schema-modified.outputs.db_changed == 'true'
        id: tags
        uses: ./.github/actions/compute-db-image-tags
        with:
          branch: ${{ github.ref_name }}

      - name: Show resolved tags (debug)
        if: needs.schema-modified.outputs.db_changed == 'true'
        shell: bash
        run: |
          echo "Tags to apply for ${{github.ref_name}}:"
          echo "Image:  ${{ steps.tags.outputs.image_name }}"

          WARNING="${{ steps.tags.outputs.warning }}"
          if [ -n "$WARNING" ]; then
            echo "::warning::${WARNING}"
          fi

          echo "${{ steps.tags.outputs.tags }}"

      # -------- build using whichever tag set exists --------
      - name: Build and Push Multi-Platform Image
        if: needs.schema-modified.outputs.db_changed == 'true'
        run: |
          set -euo pipefail

          # Collect the newline-separated tags from whichever step ran
          TAGS_COMBINED="${{ steps.tags.outputs.tags }}"

          # Turn them into an array safely (preserve spaces, handle newlines)
          mapfile -t TAGS < <(printf '%s\n' "$TAGS_COMBINED" | sed '/^$/d')

          if [ ${#TAGS[@]} -eq 0 ]; then
            echo "No tags were produced by the compute-tag steps."
            exit 1
          fi

          echo "Tags to apply:"
          printf '  %s\n' "${TAGS[@]}"

          # Build list of -t args
          TAG_ARGS=()
          for t in "${TAGS[@]}"; do
            TAG_ARGS+=( -t "$t" )
          done

          # Build & push
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --push \
            "${TAG_ARGS[@]}" \
            ./database
